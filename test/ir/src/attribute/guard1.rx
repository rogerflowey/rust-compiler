
// Test 2: Boolean Array Operations
// Tests optimization of Boolean array manipulation and pattern detection
fn testBooleanArrayOperations() {
    printlnInt(1103); // Start Boolean array test

    let mut bool_grid: [bool; 10000] = [false; 10000]; // 100x100 Boolean grid
    let mut pattern_count: i32 = 0;
    let mut row: i32 = 0;

    // Initialize Boolean grid with patterns
    while (row < 100) {
        let mut col: i32 = 0;
        while (col < 100) {
            let index: i32 = row * 100 + col;
            // Create checkerboard pattern with modifications
            bool_grid[index as usize] = ((row + col) % 2 == 0) && (row % 3 != 0);
            col = col + 1;
        }
        row = row + 1;
    }

    // Perform Boolean operations on the grid
    performBooleanGridOperations(bool_grid, &mut pattern_count);

    // Count specific Boolean patterns
    pattern_count = pattern_count + countBooleanPatterns(bool_grid);

    printlnInt(pattern_count);
    printlnInt(1104); // End Boolean array test
}

// Perform various Boolean operations on grid
fn performBooleanGridOperations(mut grid: [bool; 10000], pattern_count: &mut i32) {
    let mut operations: i32 = 0;
    let mut row: i32 = 1;

    // Apply Boolean cellular automaton rules
    while (row < 99) {
        let mut col: i32 = 1;
        while (col < 99) {
            let index: i32 = row * 100 + col;

            // Count Boolean neighbors
            let neighbor_count: i32 = countBooleanNeighbors(grid, row, col);

            // Apply Boolean rules based on neighbors
            if (grid[index as usize] && (neighbor_count < 2 || neighbor_count > 3)) {
                grid[index as usize] = false;
                operations = operations + 1;
            } else if (!grid[index as usize] && neighbor_count == 3) {
                grid[index as usize] = true;
                operations = operations + 1;
            }

            col = col + 1;
        }
        row = row + 1;
    }

    *pattern_count = *pattern_count + operations;
}

// Count Boolean neighbors in grid
fn countBooleanNeighbors(grid: [bool; 10000], row: i32, col: i32) -> i32 {
    let mut count: i32 = 0;
    let mut dr: i32 = -1;

    while (dr <= 1) {
        let mut dc: i32 = -1;
        while (dc <= 1) {
            if (dr != 0 || dc != 0) {
                let nr: i32 = row + dr;
                let nc: i32 = col + dc;
                if (nr >= 0 && nr < 100 && nc >= 0 && nc < 100) {
                    let neighbor_index: i32 = nr * 100 + nc;
                    if (grid[neighbor_index as usize]) {
                        count = count + 1;
                    }
                }
            }
            dc = dc + 1;
        }
        dr = dr + 1;
    }

    return count;
}

// Count specific Boolean patterns in grid
fn countBooleanPatterns(grid: [bool; 10000]) -> i32 {
    let mut pattern_count: i32 = 0;
    let mut row: i32 = 0;

    // Look for specific Boolean patterns
    while (row < 98) {
        let mut col: i32 = 0;
        while (col < 98) {
            // Check for 2x2 Boolean patterns
            if (checkBooleanPattern2x2(grid, row, col)) {
                pattern_count = pattern_count + 1;
            }

            // Check for 3x3 Boolean patterns
            if (checkBooleanPattern3x3(grid, row, col)) {
                pattern_count = pattern_count + 2;
            }

            col = col + 1;
        }
        row = row + 1;
    }

    return pattern_count;
}

// Check for specific 2x2 Boolean pattern
fn checkBooleanPattern2x2(grid: [bool; 10000], row: i32, col: i32) -> bool {
    let tl: bool = grid[(row * 100 + col) as usize];
    let tr: bool = grid[(row * 100 + col + 1) as usize];
    let bl: bool = grid[((row + 1) * 100 + col) as usize];
    let br: bool = grid[((row + 1) * 100 + col + 1) as usize];

    // Look for specific patterns
    return (tl && !tr && !bl && br) || (!tl && tr && bl && !br);
}

// Check for specific 3x3 Boolean pattern
fn checkBooleanPattern3x3(grid: [bool; 10000], row: i32, col: i32) -> bool {
    if (row + 2 >= 100 || col + 2 >= 100) {
        return false;
    }

    let mut true_count: i32 = 0;
    let mut r: i32 = 0;

    while (r < 3) {
        let mut c: i32 = 0;
        while (c < 3) {
            if (grid[((row + r) * 100 + (col + c)) as usize]) {
                true_count = true_count + 1;
            }
            c = c + 1;
        }
        r = r + 1;
    }

    // Pattern: exactly 5 true values in 3x3 grid
    return true_count == 5;
}

fn main() {
    testBooleanArrayOperations();
    exit(0);
}