// Test 4: Edge case - combining large stack allocations with function calls
// Tests stack management when mixing large local arrays and function calls
fn process_array(mut arr: [i32; 256], size: usize) -> i32 {
    // Create another local array inside the function
    let mut temp: [i32; 128] = [0; 128];
    
    let mut sum: i32 = 0;
    let mut i: usize = 0;
    
    // Copy and sum elements
    while (i < size) {
        if (i < 128) {
            temp[i] = arr[i];
        }
        sum = sum + arr[i];
        i = i + 1;
    }
    
    return sum;
}

fn main() {
    // Create a large array on the stack
    let mut data: [i32; 256] = [0; 256];
    
    // Initialize the array
    let mut i: usize = 0;
    while (i < 256) {
        data[i] = (i % 10) as i32;
        i = i + 1;
    }
    
    // Call function with the array, which will allocate more on the stack
    let result: i32 = process_array(data, 256 as usize);
    printlnInt(result);
    
    // Sum should be: 256 full iterations of (0+1+...+9)
    // which is 256 * 45 / 10 = 1152 (since pattern repeats every 10)
    // Actually: 0,1,2,3,4,5,6,7,8,9,0,1,2,... repeated 25.6 times in 256 elements
    // Sum = (0+1+2+3+4+5+6+7+8+9)*25 + (0+1+2+3+4+5) = 45*25 + 21 = 1146
    
    exit(0);
}
